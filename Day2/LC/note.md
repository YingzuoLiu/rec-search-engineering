# Day 2 Algorithm Study Summary

## 今日主题
- LeetCode 基础题：字符串 & 栈
- 建立 Python 基础语法直觉（list / dict / 索引 / 条件逻辑）

---

## LeetCode 242 — Valid Anagram

### 核心问题
判断两个字符串是否由**相同字母、相同次数**组成。

---

### 解题核心思想（人话版）
- 先统计第一个字符串里「每个字母有多少」
- 再用第二个字符串去“消耗”这些字母
- 如果出现某个字母不够用 → 一定不是 anagram

---

### 关键实现点

#### 1️⃣ 为什么用 `[0] * 26`
- 英文字母只有 `a ~ z` 共 26 个
- 用长度为 26 的数组当「计数表」
- 下标 `0 ~ 25` 分别对应 `a ~ z`

#### 2️⃣ `ord(ch) - ord('a')` 是什么
- 把字母映射成数组下标
- `'a' → 0`, `'b' → 1`, …, `'z' → 25`
- 目的是：**用字母直接访问数组位置**

#### 3️⃣ 正负号的含义
- `+1`：在 s 里看到一个字母（存货）
- `-1`：在 t 里用掉一个字母（取货）
- 出现负数：说明 t 用的比 s 有的多 → 失败

---

### 思维模板（以后看到就能用）
> 计数类字符串问题  
> → 初始化计数表  
> → 第一个字符串加  
> → 第二个字符串减  
> → 中途出现异常直接返回

---

## LeetCode 20 — Valid Parentheses

### 核心问题
判断括号字符串是否**正确配对 & 正确嵌套**

---

### 核心数据结构：栈（stack）

```python
stack = []
Python 用 list 模拟栈

append() = 放入栈顶

pop() = 移除栈顶

stack[-1] = 查看栈顶元素
```

### 为什么一定要用栈？

- 括号规则是：**后打开的，先关闭**
- 这是典型的「后进先出（LIFO）」场景
- 栈天然符合这个顺序

---

### 字典的作用
```python
mp = {')':'(', ']':'[', '}':'{'}
```

含义：

- 右括号 → 它应该匹配的左括号
- 用来快速判断「配对是否正确」

---

### 核心逻辑拆解（人话流程）

```python
if ch in mp:            # 是右括号
    if stack 为空 或 栈顶不匹配:
        return False
    else:
        pop 栈顶（成功配对）
else:                   # 是左括号
    push 进栈


- 如果当前字符是右括号  
  - 如果栈为空，或者栈顶不匹配  
    - 直接返回不合法  
  - 否则  
    - 弹出栈顶（成功配对）

- 如果当前字符是左括号  
  - 直接压入栈中
```
---

### 关键理解点

#### 1️⃣ `ch in mp` 在判断什么？

- 判断当前字符是不是 **右括号**
- 左括号不在 `mp`，直接入栈

#### 2️⃣ 为什么匹配成功就 `pop()`

- 栈里存的是「还没匹配的左括号」
- 成功匹配一对 → 这对已经完成 → 必须移除

#### 3️⃣ `stack[-1]` 里的 `-1`

- Python 支持负索引
- `-1` 表示「最后一个元素」
- 对应栈顶（最近入栈的左括号）

#### 4️⃣ `return not stack`

- 栈为空 → 所有左括号都被成功匹配
- 栈非空 → 还有没配对的左括号 → 不合法

---

## Python 符号体系梳理（今日高频困惑点）

| 符号 | 含义 | 在题目中的角色 |
| --- | --- | --- |
| `{}` | 字典 / 集合 | 右括号 → 左括号映射 |
| `[]` | 列表 | 当作栈使用 |
| `()` | 函数调用 / 分组 / 元组 | 语法结构 |
| `-1` | 倒数第一个索引 | 访问栈顶 |



