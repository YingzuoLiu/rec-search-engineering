# Day 4 · 双指针核心总结（LC26 / LC27 / LC283）

## 一、总规则

**双指针题里：  
fast 永远负责"找 / 扫描"，  
slow 永远负责"标记结果结构（写入 / 边界）"。**

**slow 从来不"找"元素。**

### slow 的移动规则

**slow 只在"当前位置最终可以确定"时才允许移动**

- **如果当前位置只是"最终会在某个区域"，但下标不确定：**
  - **❌ 不动 slow**
  - **✅ 继续用 fast 扫描**

**对应三题：**
- **LC26：新元素的位置立刻确定 → slow 立刻动**
- **LC27：合法元素写入位置确定 → slow 立刻动**
- **LC283：只有非 0 的位置确定 → slow 只为非 0 动**

**👉 slow 永远不为"暂时还没定位置的元素"服务**

## 二、为什么双指针一定要分 slow / fast？

**因为这类题同时在做两件事：**

1. **扫描整个数组（不能漏）**
2. **原地构建一个新的"结果结构"**

**👉**
- **fast = 扫描指针（读）**
- **slow = 结果指针（写 / 标记）**

**如果把这两个角色混在一起，就一定会写反。**

## 三、今天三道题的本质区别

### 1️⃣ LC26 --- Remove Duplicates（去重 = 结构压缩）

**你删除的是什么？  
→ 重复的"副本"**

**剩下的是什么？  
→ 每个值的唯一代表（有序、紧凑）**

#### slow 的真实含义

**去重后结果区的"边界"（最后一个合法元素）**

```
[ 去重结果 | 未处理 ]
           ↑
         slow
```

- **fast：找"新值"**
- **slow：记录"已经有多少个不同值"**

**关键点：**
- **删除重复 = 结构自然压缩**
- **新元素的位置立刻确定**

### 2️⃣ LC27 --- Remove Element（删除 = 条件过滤）

**你删除的是什么？  
→ 所有等于 val 的元素（整类）**

**剩下的是什么？  
→ 一个"幸存者集合"（顺序保持，但无结构）**

#### slow 的真实含义

**下一个可以写入合法元素的位置**

```
[ 合法元素 | 未处理 ]
           ↑        ↑
         slow     fast
```

- **fast：扫描每个元素**
- **slow：把"合法的"依次搬到前面**

**关键点：**
- **删除 ≠ 压缩结构**
- **只是过滤，不是重建顺序**

### 3️⃣ LC283 --- Move Zeroes（移动 = 稳定重排）

**你"移走"的是什么？  
→ 中间的 0**

**剩下的是什么？  
→ 所有非 0（必须保持相对顺序）**

#### slow 的真实含义

**下一个"非 0"应该放的位置**

```
[ 非0区 | 未处理 | 0区 ]
        ↑        ↑
      slow     fast
```

- **fast：找非 0**
- **slow：接收非 0**

#### 为什么用 swap？

- **因为你不仅要把非 0 放前面**
- **还要把 0 推到后面**
- **一次 swap 同时完成两件事**

## 四、重要的笔记

### 1️⃣ "remove ≠ 位置不确定"

- **LC26 也是 remove  
  → 但剩余元素形成紧凑结构**
- **LC27 / LC283 是 remove  
  → 剩余元素只是"被过滤/重排"**

**👉  
决定位置的不是"删不删"，  
而是"删完后，剩下的元素有没有结构"。**

### 2️⃣ "0 在最后 ≠ 位置已确定"

- **在 LC283 中：**
  - **我们只知道：0 在最后一段**
  - **但不知道：每个 0 的具体下标**

- **所以：**
  - **0 的位置不能立刻确定**
  - **非 0 的位置可以**

**👉  
只能为"位置能确定的元素"推动 slow。**

## 五、slow / fast 的一句话终极定义（建议背）

| **题目** | **fast 在做什么** | **slow 在做什么** |
|----------|-------------------|-------------------|
| **LC26** | **找新元素** | **标记去重结果边界** |
| **LC27** | **扫描数组** | **指向下一个写入位置** |
| **LC283** | **找非 0** | **指向下一个非 0 位置** |

**👉 fast 找，slow 放 / 标记结构**

## 六、写双指针前的 3 个自问

**以后再看到双指针题，先别写代码，先问：**

1. **删的是什么？（重复 / 某个值 / 阻塞元素）**
2. **删完后，剩下的元素有没有"结构"？**
3. **slow 是"边界"，还是"写入位置"？**

## 双指针的初始化判断（同侧 or 对撞）

- 如果题目目标是：
  - **构建数组前缀结构**
  - 删除 / 过滤 / 稳定整理  
    → **两个指针从同一侧开始**

- 如果题目目标是：
  - 比较区间两端
  - 在范围内做最优 / 剪枝  
    → **指针一左一右对撞**

**例子：**
- LC26 / 27 / 283：同向双指针
- LC11 / LC15（内层）：对撞双指针

## ⚠️ 双指针常见致命误区

- 把 slow 当成"查找指针"（❌）  
  👉 查找永远是 fast 的职责

- 为"最终会在后面"的元素提前移动 slow（❌）  
  👉 区域确定 ≠ 位置确定

- 用 swap / 赋值时写反方向（❌）  
  👉 数据永远从 fast → slow

  # 循环语义与双指针核心不变量

## 循环语义区别

- **`for`** 是在"遍历"
- **`while`** 是在"维护条件 / 比较关系"

## 双指针的核心不变量（非常重要）

在回文 / 反转类问题中：

- `left` 从左向右
- `right` 从右向左
- **只要 `left < right`，就还有一对字符需要处理**

## 为什么不是 `left > right`？

- 初始状态必然 `left <= right`
- `left > right` 意味着指针已交叉，算法早就结束
- 写成 `left > right` 会导致循环体一次都不执行
